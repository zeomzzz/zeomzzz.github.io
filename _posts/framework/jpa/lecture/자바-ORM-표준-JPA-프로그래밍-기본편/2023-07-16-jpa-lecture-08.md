---
title:  "[자바 ORM 표준 JPA 프로그래밍 - 기본편] 08강. 프록시와 연관관계 관리"
excerpt: "수강 중"

categories:
  - JPA
tags:
  - [Framework, Lecture, JPA]

toc: true
toc_sticky: true
 
date: 2023-07-16
last_modified_at: 2023-07-16
---

<br>

# **08강. 프록시와 연관관계 관리**

<br>

## **01. 프록시**

<br>    

### **프록시 기초**

<br>

- `em.find()` vs `em.getReference()`
    - `em.find()`: 데이터베이스를 통해서 실제 엔티티 객체 조회
    - `em.getReference()`: 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
        - DB에 쿼리가 나가지 않는데 객체가 조회됨
        - target이 진짜 reference를 가리킴
            
            ![]({{ site.url }}{{ site.baseurl }}/assets/images/jpa/lecture/orm/08/01.png ){: .align-center}
            
- 예제
    - getReference
        
        ```java
        Member member = new Member();
        member.setUsername("hello");
        
        em.persist(member);
        
        em.flush();
        em.clear();
        
        Member findMember = em.getReference(Member.class, member.getId());
        
        tx.commit();
        ```
        
        ```java
        Hibernate: 
            call next value for hibernate_sequence
        Hibernate: 
            /* insert hellojpa.Member
                */ insert 
                into
                    Member
                    (createdBy, createdDate, lastModifiedBy, lastModifiedDate, USERNAME, MEMBER_ID) 
                values
                    (?, ?, ?, ?, ?, ?)
        ```
        
    - getReference + ?
        
        ```java
        Member member = new Member();
        member.setUsername("hello");
        
        em.persist(member);
        
        em.flush();
        em.clear();
        
        Member findMember = em.getReference(Member.class, member.getId());
        
        System.out.println("findMember.id = " + findMember.getId()); // 파라미터로 넣은 ID는 DB에 가지 않아도 알 수 있음
        System.out.println("findMember.username = " + findMember.getUsername()); // Username은 DB에 있음. Reference에 없어서 DB에 쿼리를 날림
        
        tx.commit();
        ```
        
        ```java
        Hibernate: 
            call next value for hibernate_sequence
        Hibernate: 
            /* insert hellojpa.Member
                */ insert 
                into
                    Member
                    (createdBy, createdDate, lastModifiedBy, lastModifiedDate, USERNAME, MEMBER_ID) 
                values
                    (?, ?, ?, ?, ?, ?)
        findMember.id = 1 // DB에서 가져오지 않아도 됨
        Hibernate: // DB 찍고 가져옴
            select
                member0_.MEMBER_ID as MEMBER_I1_3_0_,
                member0_.createdBy as createdB2_3_0_,
                member0_.createdDate as createdD3_3_0_,
                member0_.lastModifiedBy as lastModi4_3_0_,
                member0_.lastModifiedDate as lastModi5_3_0_,
                member0_.TEAM_ID as TEAM_ID7_3_0_,
                member0_.USERNAME as USERNAME6_3_0_,
                team1_.TEAM_ID as TEAM_ID1_7_1_,
                team1_.createdBy as createdB2_7_1_,
                team1_.createdDate as createdD3_7_1_,
                team1_.lastModifiedBy as lastModi4_7_1_,
                team1_.lastModifiedDate as lastModi5_7_1_,
                team1_.name as name6_7_1_ 
            from
                Member member0_ 
            left outer join
                Team team1_ 
                    on member0_.TEAM_ID=team1_.TEAM_ID 
            where
                member0_.MEMBER_ID=?
        findMember.username = hello
        ```
        
    - findMember는 Proxy
        
        ```java
        Member member = new Member();
        member.setUsername("hello");
        
        em.persist(member);
        
        em.flush();
        em.clear();
        
        Member findMember = em.getReference(Member.class, member.getId());
        
        System.out.println("findMember = " + findMember.getClass());
        ```
        
        ```java
        Hibernate: 
            call next value for hibernate_sequence
        Hibernate: 
            /* insert hellojpa.Member
                */ insert 
                into
                    Member
                    (createdBy, createdDate, lastModifiedBy, lastModifiedDate, USERNAME, MEMBER_ID) 
                values
                    (?, ?, ?, ?, ?, ?)
        findMember = class hellojpa.Member$HibernateProxy$LDM2UMzq
        ```
        
        - findMember는 Member가 아니고 `Member$HibernateProxy` : Hibernate가 만든 가짜 Proxy

<br>
<br>

### **프록시 객체의 초기화**

<br>

```java
Member member = em.getReference(Member.class, “id1”);
member.getName();
```
![]({{ site.url }}{{ site.baseurl }}/assets/images/jpa/lecture/orm/08/02.png ){: .align-center}

ex. 

member는 프록시 객체를 가져온 상태

1. member.getName()을 호출
2. 처음에 Proxy를 봤는데, target에 값이 없음
3. JPA가 영속성 컨텍스트에 요청 : member 객체 가져와 : 초기화 요청 !!
4. 영속성 컨텍스트가 DB 조회해서 실제 Entity 객체를 생성해서 Member를 돌려주고 target에 연결
5. 이제 getName() 하면 target의 getName()을 통해 Member의 getName()을 반환

<br>
<br>

### **프록시의 특징**

<br>

- 실제 클래스를 상속 받아서 만들어짐 -> 실제 클래스와 겉모양이 같음
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)
- 프록시 객체는 실제 객체의 참조(target)를 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출
    
    ![]({{ site.url }}{{ site.baseurl }}/assets/images/jpa/lecture/orm/08/03.png ){: .align-center}
    
    - ex. getName()을 호출하면 target에 있는 getName()을 호출
    - 처음에는 target 비어 있음 : DB에서 조회한 적이 없으니까
- 프록시 객체는 처음 사용할 때 한 번만 초기화
    - 한 번 초기화하면 계속 사용
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님!!!
    - 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능한 것
    - 예제 : before findMember와 after findMember가 동일
        
        ```java
        Member member = new Member();
        member.setUsername("hello");
        
        em.persist(member);
        
        em.flush();
        em.clear();
        
        Member findMember = em.getReference(Member.class, member.getId());
        
        System.out.println("before findMember = " + findMember.getClass());
        System.out.println("findMember.username = " + findMember.getUsername());
        System.out.println("after findMember = " + findMember.getClass());
        
        tx.commit();
        ```
        
        ```java
        Hibernate: 
            call next value for hibernate_sequence
        Hibernate: 
            /* insert hellojpa.Member
                */ insert 
                into
                    Member
                    (createdBy, createdDate, lastModifiedBy, lastModifiedDate, USERNAME, MEMBER_ID) 
                values
                    (?, ?, ?, ?, ?, ?)
        before findMember = class hellojpa.Member$HibernateProxy$L2EuOtQa
        Hibernate: 
            select
                member0_.MEMBER_ID as MEMBER_I1_3_0_,
                member0_.createdBy as createdB2_3_0_,
                member0_.createdDate as createdD3_3_0_,
                member0_.lastModifiedBy as lastModi4_3_0_,
                member0_.lastModifiedDate as lastModi5_3_0_,
                member0_.TEAM_ID as TEAM_ID7_3_0_,
                member0_.USERNAME as USERNAME6_3_0_,
                team1_.TEAM_ID as TEAM_ID1_7_1_,
                team1_.createdBy as createdB2_7_1_,
                team1_.createdDate as createdD3_7_1_,
                team1_.lastModifiedBy as lastModi4_7_1_,
                team1_.lastModifiedDate as lastModi5_7_1_,
                team1_.name as name6_7_1_ 
            from
                Member member0_ 
            left outer join
                Team team1_ 
                    on member0_.TEAM_ID=team1_.TEAM_ID 
            where
                member0_.MEMBER_ID=?
        findMember.username = hello
        after findMember = class hellojpa.Member$HibernateProxy$L2EuOtQa
        ```
        
- 프록시 객체는 원본 엔티티를 상속 받음. 따라서 타입 체크시 == 가 아닌 instanceof 로 비교
    - 예제
        - find 결과를 비교
            
            ```java
            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);
            
            Member member2 = new Member();
            member2.setUsername("member2");
            em.persist(member2);
            
            em.flush();
            em.clear();
            
            Member m1 = em.find(Member.class, member1.getId());
            Member m2 = em.find(Member.class, member2.getId());
            
            System.out.println("m1 == m2 : " + (m1.getClass() == m2.getClass())); // true
            
            tx.commit();
            ```
            
        - find 와 getReference 결과를 비교
            - 실제로 proxy가 넘어올지 실제 객체가 넘어올지 모르기 때문에 절대 ==으로 type 비교를 하면 안됨
                
                ```java
                Member member1 = new Member();
                member1.setUsername("member1");
                em.persist(member1);
                
                Member member2 = new Member();
                member2.setUsername("member2");
                em.persist(member2);
                
                em.flush();
                em.clear();
                
                Member m1 = em.find(Member.class, member1.getId());
                Member m2 = em.getReference(Member.class, member2.getId());
                
                System.out.println("m1 == m2 : " + (m1.getClass() == m2.getClass())); // false (type 비교여서)
                
                tx.commit();
                ```
                
            - instanceof로 비교
                
                ```java
                Member member1 = new Member();
                member1.setUsername("member1");
                em.persist(member1);
                
                Member member2 = new Member();
                member2.setUsername("member2");
                em.persist(member2);
                
                em.flush();
                em.clear();
                
                Member m1 = em.find(Member.class, member1.getId());
                Member m2 = em.getReference(Member.class, member2.getId());
                
                logic(m1, m2);
                // m1 == m2 : true
                // m1 == m2 : true
                ```
                
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
    - 예제
        
        ```java
        Member member1 = new Member();
        member1.setUsername("member1");
        em.persist(member1);
        
        em.flush();
        em.clear();
        
        Member m1 = em.find(Member.class, member1.getId());
        System.out.println("m1 = " + m1.getClass()); // m1 = class hellojpa.Member
        
        // 현재 m1이 영속성 컨텍스트에 올라가 있는 상태
        Member reference = em.getReference(Member.class, member1.getId());
        System.out.println("reference = " + reference.getClass()); // reference = class hellojpa.Member
        
        tx.commit();
        ```
        
        - 이유
            1. JPA는 한 영속성 컨텍스트에서 가져온 것을 비교하면 항상 true를 반환을 보장
            2. 이미 영속성 컨텍스트에 올라와있는데 Proxy를 가져오는 것이 이점이 없음
- 한 번 Proxy를 조회하면 em.find에서도 Proxy를 반환
    
    ```java
    Member member1 = new Member();
    member1.setUsername("member1");
    em.persist(member1);
    
    em.flush();
    em.clear();
    
    Member refMember = em.getReference(Member.class, member1.getId());
    System.out.println("refMember = " + refMember.getClass()); // refMember = class hellojpa.Member$HibernateProxy$WmuYKyAh
    
    Member findMember = em.find(Member.class, member1.getId());
    System.out.println("findMember = " + findMember.getClass()); // findMember = class hellojpa.Member$HibernateProxy$WmuYKyAh
    // findMember 했는데 Proxy를 반환
    // 왜냐하면,, 한 번 Proxy를 조회하면 em.find에서 Proxy를 반환
    
    System.out.println("refMember == findMember : " + (refMember == findMember)); // refMember == findMember : true
    
    tx.commit();
    ```
    
- ⭐️ 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생 (Hibernate는 `org.hibernate.LazyInitializationException` 예외)
    
    ```java
    try {
    
    		Member member1 = new Member();
    	  member1.setUsername("member1");
    	  em.persist(member1);
    
    		em.flush();
    		em.clear();
    
    		Member refMember = em.getReference(Member.class, member1.getId());
    		System.out.println("refMember = " + refMember.getClass()); // Proxy
    
    		em.detach(refMember); // 영속성 컨텍스트에서 꺼내버림
    		// em.close(); // 이거도 마찬가지
    		// em.clear();
    
    		refMember.getUsername();
    		// 영속성 컨텍스트의 도움을 받아서 초기화해야하는데 영속성 컨텍스트에서 관리하지 않고 있음
    		// 따라서 could not initialize proxy
    
    		tx.commit();
    
    } catch (Exception e) {
    
    		tx.rollback();
    		e.printStackTrace();
    
    } finally {
    
    		em.close();
    
    }
    ```

<br>
<br>

### **프록시 확인**

<br>

- 프록시 인스턴스의 초기화 여부 확인 : `emf.getPersistenceUnitUtil().isLoaded(Object entity)`
    - 초기화 전
        
        ```java
        Member member1 = new Member();
        member1.setUsername("member1");
        em.persist(member1);
        
        em.flush();
        em.clear();
        
        Member refMember = em.getReference(Member.class, member1.getId());
        System.out.println("refMember = " + refMember.getClass()); // Proxy
        
        System.out.println("isLoaded = " + emf.getPersistenceUnitUtil().isLoaded(refMember)); // false
        
        tx.commit();
        ```
        
    - 초기화 후
        
        ```java
        Member member1 = new Member();
        member1.setUsername("member1");
        em.persist(member1);
        
        em.flush();
        em.clear();
        
        Member refMember = em.getReference(Member.class, member1.getId());
        System.out.println("refMember = " + refMember.getClass()); // Proxy
        refMember.getUsername(); // 초기화
        System.out.println("isLoaded = " + emf.getPersistenceUnitUtil().isLoaded(refMember)); // true
        
        tx.commit();
        ```
        
- 프록시 클래스 확인 방법 : `entity.getClass().getName()` 출력
    
    ```java
    Member member1 = new Member();
    member1.setUsername("member1");
    em.persist(member1);
    
    em.flush();
    em.clear();
    
    Member refMember = em.getReference(Member.class, member1.getId());
    System.out.println("refMember = " + refMember.getClass()); // refMember = class hellojpa.Member$HibernateProxy$bPWWO9Gu
    
    tx.commit();
    ```
    
- 프록시 강제 초기화 : `org.hibernate.Hibernate.initialize(entity);`
    
    ```java
    Member member1 = new Member();
    member1.setUsername("member1");
    em.persist(member1);
    
    em.flush();
    em.clear();
    
    Member refMember = em.getReference(Member.class, member1.getId());
    System.out.println("refMember = " + refMember.getClass());
    
    Hibernate.initialize(refMember);
    
    tx.commit();
    ```
    
    ```java
    Hibernate: 
        call next value for hibernate_sequence
    Hibernate: 
        /* insert hellojpa.Member
            */ insert 
            into
                Member
                (createdBy, createdDate, lastModifiedBy, lastModifiedDate, USERNAME, MEMBER_ID) 
            values
                (?, ?, ?, ?, ?, ?)
    refMember = class hellojpa.Member$HibernateProxy$X96OXpP5
    Hibernate: 
        select
            member0_.MEMBER_ID as MEMBER_I1_3_0_,
            member0_.createdBy as createdB2_3_0_,
            member0_.createdDate as createdD3_3_0_,
            member0_.lastModifiedBy as lastModi4_3_0_,
            member0_.lastModifiedDate as lastModi5_3_0_,
            member0_.TEAM_ID as TEAM_ID7_3_0_,
            member0_.USERNAME as USERNAME6_3_0_,
            team1_.TEAM_ID as TEAM_ID1_7_1_,
            team1_.createdBy as createdB2_7_1_,
            team1_.createdDate as createdD3_7_1_,
            team1_.lastModifiedBy as lastModi4_7_1_,
            team1_.lastModifiedDate as lastModi5_7_1_,
            team1_.name as name6_7_1_ 
        from
            Member member0_ 
        left outer join
            Team team1_ 
                on member0_.TEAM_ID=team1_.TEAM_ID 
        where
            member0_.MEMBER_ID=?
    ```
    
- 참고: JPA 표준은 강제 초기화 없음
    - 강제 호출 : `member.getName()`

<br>
<br>

## **02. 즉시 로딩과 지연 로딩**